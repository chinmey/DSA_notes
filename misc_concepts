*** Counting Sort ***


274. H-Index  (https://www.youtube.com/watch?v=mgG5KFTvfPw)

Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index
The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h time

Input: citations = [3,0,6,1,5]
Output: 3
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.


Brute force :: Start from h =1 (traverse array as soon as we see h numbers greater than or equal to h, it could be possible answer break and try one higher)
This will need O(N) traversal of array atmost N times so O(N2)

Optimized : keep a paper_count[n+1] = {0}, as well go thru each element inc its paper_count , so if paper_count[i] = x, shows that there are x papers with
exactly i citations for all numbers greater than n put it in nth bucket

Post traversing : paper_count = [1,1,0,1,0,2] {since n is 5 array has 6 eleemnts} go thru this array backwards so h = 5, and keep on summing as soon as 
sum crosses that is answer

h--> 5 sum =2 , h-->4 sum =2 , h --> 3 sum = 3 (answer)

class Solution {
public:
    int hIndex(vector<int>& citations) {
        
        int n = citations.size();

        vector<int> count(n+1,0);

         for (int i = 0; i < n; i++) {
            if (citations[i] >= n) {
                count[n]++;
            } else {
                count[citations[i]]++;
            }
        }

        int h_index = n;
        int p_count = 0;

        for(int i=n; i>=0; i--) {
            p_count+= count[i];
            if(p_count >= h_index) {
                return h_index;
            }
            h_index--;
        }

        return 0;
    }
};

238. Product of Array Except Self

Create two auxiliary arrays:

left where left[i] holds the product of all elements to the left of index i.
right where right[i] holds the product of all elements to the right of index i.
Calculate products in two passes:

Fill left by iterating from the start of the array.
Fill right by iterating from the end of the array.
Combine left and right:

The product of all elements except nums[i] will be left[i] * right[i]


380. Insert Delete GetRandom O(1)

We can do insert and GetRandom in vector directly issue is with delete since that requires traversing array to avoid same just keep a unoredered_map which
stores number and its index , while removing replace the last element with number to be deleted and delete number


Another way could be to maintain : map<int, pair<int,int>> where the extra int stores if number is valid or not (already removed)

135. Min Total Candy

You are giving candies to these children subjected to the following requirements:

Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.

Needs 2 passes one from l-->r and other from r-->l


*** Sub-Array sum/count divisible by k type problems ****

974. Count Subarray Sums Divisible by K

One general concept used in array is sum between any index i and j can be calculated in O(1) , create a cummulative sum array than ans = sum[j] - sum[i-1];

Ex : 1 2 3 7  (let say i=1 j = 3 ans is 12) 
Using approach :: 1 3 6 13 , 13 -1 = 12

One way to do this will be used try every i ( from 0 to n) and every j from (i to n) get the sum using above technique and see if it is divisable , O(N2)

Optimal solution build on this , lets say prefix[i] % k = x and prefix[j] %k =x , than we can be sure that array between i and j that is divisable by k,
in the example above lets say k was 10 , than p[3]%k = 3 and p[1]%k = 3 ( so array of element 2 and 3 that is divisable by k) 

Now coming at a number and calculating remainder of cummulative sum till it , we would need to know if it is seen before for that we need map

So traverse from 0 to i , keep on storing cummulative_sum % k as remainder in map , if remainder is seen already add it in answer and do mp[rem]++;

1590. Make Sum Divisible by P

Solved using same idea , since we calculate cum_sum of array % p and we need minium length subrray with sum as that and we remove that

