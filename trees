Inorder -- left root right  Preorder -- root left right  Postorder --- left right root

WIth recursion all are straightforwrad just make call in same way

Iterative way
Inituition is to keep a array and store state of node (1 for in , 2 for pre, 3 for post) and solve accoridingly

stack<pair<TreeNode*,int>> s;
        s.push({root, 1});

        while(!s.empty()) {
            pair<TreeNode*, int> top = s.top();

            int state = top.second;
            TreeNode* node = top.first;

            if(state == 1) {
                pre.push_back(node->val);
                s.pop();
                s.push({node, 2});
                if(node->left != nullptr) {
                    s.push({node->left, 1});
                }
            } else if(state == 2) {
                in.push_back(node->val);
                s.pop();
                s.push({node, 3});
                if(node->right != nullptr) {
                    s.push({node->right, 1});
                }
            } else if(state == 3) {
                post.push_back(node->val);
                s.pop();
            }
 }

Morris inorder traversal (using no extra space)

We have 2 observations from using recursion and what it helps us with we need to simulate both here 

> Right is processed only when either left does not exists or left is already fully processed
> Recursion makes a connection between a root and its rightmost node in its left tree 

We need to do both here and think on those two points

vector<int> in;
    TreeNode* curr = root;

    while (curr != nullptr) {
        if (curr->left == nullptr) {
            // Process the node if there's no left subtree
            in.push_back(curr->val);
            curr = curr->right;  // Move to the right subtree
        } else {
            // Find the inorder predecessor (rightmost node of the left subtree)
            TreeNode* pre = curr->left;
            while (pre->right != nullptr && pre->right != curr) {
                pre = pre->right;
            }

            if (pre->right == nullptr) {
                // Create a temporary link to the current node
                pre->right = curr;
                curr = curr->left;  // Move to the left subtree
            } else {
                // Remove the temporary link (restoring the tree)
                pre->right = nullptr;
                in.push_back(curr->val);
                curr = curr->right;  // Move to the right subtree
            }
        }
}

we just change making and removing of connection part in pre-order (line in.push_back(curr->val); is moved to if)


Level order traversal --> BFS use a queue put root in it and pop front of queue and push children in (we can use some delimiter for level like nullptr etc)


Is tree symmetric ? --> for tree to be symmetric its child should be mirror image of each other and that should hold true for all their childs and so on 

bool areMirror(TreeNode* left, TreeNode* right) {
    if (left == nullptr && right == nullptr) return true;
    if (left == nullptr || right == nullptr) return false;

    // This is the critical check you're missing
    return (left->val == right->val) 
        && areMirror(left->right, right->left) 
        && areMirror(left->left, right->right);
}

bool isSymmetric(TreeNode* root) {
    return areMirror(root->left, root->right);
}

Invert a tree ? 

void invertHelper(TreeNode* node) {
    if (node == nullptr) return;

    // Swap the left and right children
    TreeNode* temp = node->left;
    node->left = node->right;
    node->right = temp;

    // Recursively invert the subtrees
    invertHelper(node->left);
    invertHelper(node->right);
}

Left view of tree : first node in each level (easy in BFS) (for DFS use pre-order and take first node in each level)


Top view of tree : track horizontol distance each one for a level is to be returned there are two ways to do this now 

If we have independent copies than we dont need to care about backtracking etc 

void fillMap(Node* root, int d) {
        if (root == NULL) return;
        
        // Only add the node if it is the first one encountered at that distance
        if (mp.find(d) == mp.end()) {
            mp[d] = root->data;
        }
        
        // Correctly propagate the horizontal distance
        fillMap(root->left, d - 1);  // Left child goes to d - 1
        fillMap(root->right, d + 1); // Right child goes to d + 1
}

Using single copy 
void fillMap(Node* root, int &d) {
        if (root == nullptr) return;

        if (mp.find(d) == mp.end()) {
            mp[d] = root->data;
        }

        // Increment for left child
        d--;
        fillMap(root->left, d); // Move to the left child
        d++; // Backtrack to the original value for the right child
        d++;
        fillMap(root->right, d); // Move to the right child
        d--; // Backtrack to the original value after right child
 }


Diameter of tree 

The diameter of a binary tree is the length of the longest path between any two nodes in a tree

Initution 

For each node there are two responsibility first check if its left+right can be answer (in case answer passes thru it)
Pass the max(left,right) to its parent (in case answer does not pass thru it)

int result = 0;
    int solve(TreeNode* root) {
        
        if(root == NULL) return 0;

        int l = solve(root->left);
        int r = solve(root->right);

        result = max(result, l+r);

        return max(l,r) + 1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        
        int s = solve(root);

        return result;
    }

Similar code for max sum between any two nodes 

class Solution {
public:
    int maxSum = INT_MIN;

    int solve(TreeNode* root) {
        if (root == nullptr) return 0;

        // Recursively calculate the maximum sum from left and right subtrees
        int leftSum = max(0, solve(root->left));  // Ignore negative sums, treat them as 0
        int rightSum = max(0, solve(root->right));

        int currentSum = leftSum + rightSum + root->val;

        maxSum = max(maxSum, currentSum);

        return root->val + max(leftSum, rightSum);
    }

    int maxPathSum(TreeNode* root) {
        solve(root);
        return maxSum;
    }
};


LCA of 2 nodes in tree

One way is to get path for root->node of both and see where it differes 
But we have another better way , using observations for a inorder traversal


if while traversing we get either a or b than return that , it is LCA
if both a and b are in different subtree than root is answer 
and rely on rest for recursion


TreeNode* findLCA(TreeNode* root, TreeNode* p, TreeNode* q) {
    // Base case: if root is NULL or root is either p or q, return root
    if (root == nullptr || root == p || root == q) {
        return root;
    }

    // Recur for the left and right subtrees
    TreeNode* leftLCA = findLCA(root->left, p, q);
    TreeNode* rightLCA = findLCA(root->right, p, q);

    // If both the left and right subtree calls return non-null, 
    // it means p and q are found in different subtrees, hence root is their LCA.
    if (leftLCA != nullptr && rightLCA != nullptr) {
        return root;
    }

    // Otherwise, return the non-null result from left or right (if only one subtree contains p or q)
    return (leftLCA != nullptr) ? leftLCA : rightLCA;
}


Path sum , given a sum find out if there exists any path between root->leaf which equals a target

One way is to get all path sums and see if one matches , better is this 

bool hasPathSum(TreeNode* root, int targetSum) {
    // Base case: If the tree is empty, there's no path, so return false.
    if (root == nullptr) {
        return false;
    }

    // Subtract the current node's value from the target sum.
    targetSum -= root->val;

    // If we reach a leaf node (both left and right are null), check if the target sum is 0.
    if (root->left == nullptr && root->right == nullptr) {
        return targetSum == 0;
    }

    // Recursively check the left and right subtrees.
    // If either subtree has a path that results in the target sum, return true.
    return hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum);
}

Boundary traversal of tree 


Problem can be broken down into left/leaves/right

Idea for left is to go as left as possible if we reach leave we return if we reach a node with only right child than we go right

class Solution {
public:
    void populateLeft(vector<int> &ans, TreeNode* root) {
        if(root == NULL) return;

        if(root->left == NULL && root->right == NULL) return;

        ans.push_back(root->val);

        if(root->left != NULL) populateLeft(ans, root->left);
        else if(root->right != NULL) populateLeft(ans, root->right);
    }

     void populateRight(vector<int> &ans, TreeNode* root) {
        if(root == NULL) return;

        if(root->left == NULL && root->right == NULL) return;

        if(root->right != NULL) populateRight(ans, root->right);
        else if(root->left != NULL) populateRight(ans, root->left);
        ans.push_back(root->val);
    }

    void populateLeaves(vector<int> &ans, TreeNode* root) {
        if(root == NULL) return;
        
        if(root->left == NULL && root->right == NULL) {
            ans.push_back(root->val);
            return;
        }

        populateLeaves(ans, root->left);
        populateLeaves(ans, root->right);
    }
    vector<int> boundaryOfBinaryTree(TreeNode* root) {
        
        vector<int> ans;

        ans.push_back(root->val);

        if(root->left == NULL && root->right == NULL) return ans;

        populateLeft(ans, root->left);
        populateLeaves(ans, root);
        populateRight(ans, root->right);

        return ans;
    }
};


Check if a given tree is subTree for another given tree 

bool checkTreeSame(TreeNode* a, TreeNode* b) {
        if (!a && !b) return true;  // Both nodes are NULL, so trees are identical
        if (!a || !b) return false; // One is NULL and the other is not, so trees differ
        return (a->val == b->val) && checkTreeSame(a->left, b->left) && checkTreeSame(a->right, b->right);
    }

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if (root == nullptr) return false; // If the main tree is empty, it can't contain any subtree

        // Check if the current tree rooted at 'root' is the same as 'subRoot'
        if (checkTreeSame(root, subRoot)) return true;

        // Otherwise, check the left and right subtrees recursively
        return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
    }


Create tree from inorder and Preorder

class Solution {
public:
    // Helper function to find index of root in inorder array
    int find(int k, vector<int>& in, int inStart, int inEnd) {
        for(int i = inStart; i <= inEnd; i++) {
            if(in[i] == k) return i;
        }
        return -1;  // Should not happen if input is valid
    }

    // Recursive helper function to build the tree
    TreeNode* buildTreeHelper(vector<int>& pre, vector<int>& in, int& preIndex, int inStart, int inEnd) {
        if (inStart > inEnd) return nullptr;  // Base case: no subtree to build

        // Create the root from the current preorder index
        TreeNode* root = new TreeNode(pre[preIndex]);
        preIndex++;  // Move to the next preorder element for the next call

        // Find the root in the inorder array to split the tree
        int inIndex = find(root->val, in, inStart, inEnd);

        // Recursively build left and right subtrees
        root->left = buildTreeHelper(pre, in, preIndex, inStart, inIndex - 1);
        root->right = buildTreeHelper(pre, in, preIndex, inIndex + 1, inEnd);

        return root;
    }

    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {
        int preIndex = 0;  // Start from the first element in preorder
        return buildTreeHelper(pre, in, preIndex, 0, in.size() - 1);
    }
};

For postorder and inorder start traversing postorder array from reverse and build right tree first


Convert tree to DLL (watch codeStoryWithMIk binary tree to sorted linked list recursion video for inituition just follow same)

In short , assume karo left child ke call pe usne sorted de di and same with right child ab bs connection bana lo 

Node* bToDLL(Node* root) {
    if (root == NULL) return root;
    
    // Convert the left subtree and get the head of the left DLL
    Node* left = bToDLL(root->left);
    
    // Find the rightmost node of the left subtree (if it exists)
    if (left != NULL) {
        Node* leftEnd = left;
        while (leftEnd->right != NULL) {
            leftEnd = leftEnd->right;
        }
        
        // Link the rightmost node of the left subtree with root
        leftEnd->right = root;
        root->left = leftEnd;
    }
    
    // Convert the right subtree
    Node* right = bToDLL(root->right);
    
    // Link root to the right subtree
    if (right != NULL) {
        root->right = right;
        right->left = root;
    }
    
    // Return the head of the DLL
    return left != NULL ? left : root;
}

Check for Children Sum Property

Inituition is to check for myself if i dont violate than check for my children also (same approach is used in other questions like if tree is height balanced or not and so on)

int isSumProperty(Node *root)
    {
      if(root == NULL) return true;
      
      if (root->left == NULL && root->right == NULL) return true;
      
      int leftSum = (root->left==NULL) ? 0 : root->left->data;
      int rightSum = (root->right == NULL) ? 0 : root->right->data;
      
      int sum = leftSum + rightSum;
      
      if(sum != root->data) return false;
      
      return isSumProperty(root->left) && isSumProperty(root->right);
      
      
    }

979. Distribute candies (https://www.youtube.com/watch?v=FmHxY2104hc)

You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.

In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.

Return the minimum number of moves required to make every node have exactly one coin.


This is a classical problem which is hard to think on its own we need to trust recusion here and its similar to max-sum or diameter problem where we need to 
ask from each node something and base our answer on something 

class Solution {
public:
    int moves = 0;
    int solve(TreeNode* root) {
        if(root == NULL) return 0;
        
        if(root->left == 0 && root->right == 0) return root->val - 1;

        int left_extra_candy_left = solve(root->left);
        int right_extra_candy_left = solve(root->right);

        moves = moves + abs(left_extra_candy_left) + abs(right_extra_candy_left); // abs because both direction movement is allowed

        int total_candies_i_have = left_extra_candy_left + right_extra_candy_left + root->val;

        return total_candies_i_have - 1;
    }
    int distributeCoins(TreeNode* root) {
        
        solve(root);

        return moves;
    }
};

968. Cameras in a tree (https://www.youtube.com/watch?v=uoFrIIrp5_g)

class Solution {
public:
    // 1 i am covered , 0 i have camera , -1 i need camera
    int count =0;
    int helper(TreeNode* root)
    {
        if(root == NULL) return 1;
        
        int l =helper(root->left);
        int r=helper(root->right);
        
        if(l == -1 || r == -1) {
            count++;
            return 0;
        }
        
        if(l == 0 || r== 0) return 1;
        
        return -1;
        // if(l==1 && r == 1)
        
    }
    int minCameraCover(TreeNode* root) {
        int d =helper(root);
        if(d==-1) count++;
        return count;
    }
};

863. All Nodes Distance K in Binary Tree

The question is fairly simple to calculate for my child the issue is in parent we solve this by doing a traversal and populating parents in map 
and than doing queue based BFS 

class Solution {
public:
    unordered_map<TreeNode*, TreeNode*> parent;
    
    void fillParent(TreeNode* root) {
        if(root == NULL) return;
        
        if(root->left) {
            parent[root->left] = root;
            fillParent(root->left);
        }
        if(root->right) {
            parent[root->right] = root;
            fillParent(root->right);
        }
    }
    
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
        fillParent(root);
        
        queue<TreeNode*> q;
        unordered_set<TreeNode*> visited;
        
        q.push(target);
        visited.insert(target);
        
        vector<int> result;
        int distance = 0;
        
        while(!q.empty() && distance <= k) {
            int size = q.size();
            
            for(int i = 0; i < size; i++) {
                TreeNode* node = q.front();
                q.pop();
                
                if(distance == k) {
                    result.push_back(node->val);
                }
                
                if(node->left && visited.find(node->left) == visited.end()) {
                    q.push(node->left);
                    visited.insert(node->left);
                }
                if(node->right && visited.find(node->right) == visited.end()) {
                    q.push(node->right);
                    visited.insert(node->right);
                }
                if(parent.find(node) != parent.end() && visited.find(parent[node]) == visited.end()) {
                    q.push(parent[node]);
                    visited.insert(parent[node]);
                }
            }
            
            distance++;
        }
        
        return result;
    }
};

Kth Ancestor of a Tree Node (binary lifting) (https://leetcode.com/problems/kth-ancestor-of-a-tree-node/description/) (https://www.youtube.com/watch?v=PE-kQVZxvWA)


Inituition is to preprocess and store ancestors for all nodes so that we can answer queries in O(1)

But if we store all ancestors of all nodes it becomes too large to store in parents (as n given is 10^5)

Key is to represent a number (k) in its binary form so k = 11 is (1+ 2+ 8), so all we need is these three parents and not all.

class TreeAncestor {
public:
    vector<vector<int>> dp;
    int LOG = 20;
    TreeAncestor(int n, vector<int>& parent) {
        dp.resize(LOG, vector<int> (n, -1));

        for(int i=0; i<n; i++) {
            dp[0][i] = parent[i];
        }

        for(int i=1; i<LOG; i++) {
            for(int j=0; j<n; j++) {
                // The 2048th ancestor of j is the 1024th ancestor of j's 1024th ancestor
                int immediate_parent = dp[i-1][j];
                if(immediate_parent != -1)
                dp[i][j] = dp[i-1][immediate_parent];
            }
        }
    }
    
    int getKthAncestor(int node, int k) {
        
        for(int i=0; i<LOG; i++) {
            int mask = (1 << i);
            if (mask & k) {
                if(node == -1) return -1;
                node = dp[i][node];
            }
        }

        return node;
    }
};

This can be used to solve the Lowest Common Ancestor (LCA) problem efficiently.

The idea is to preprocess a table similar to the one you used for getKthAncestor, where you store ancestors of each node at powers of 2 distances (i.e., 2^0, 2^1, 2^2, etc.). 
Then, to find the LCA of two nodes u and v, you essentially "lift" both nodes up to the same level and then binary lift them together to find their common ancestor.

Heres how LCA can be solved using binary lifting:

Equalizing depth: If the nodes u and v are at different depths, lift the deeper node to the same depth as the shallower one.
Binary lifting to the LCA: Once they are at the same level, lift both nodes simultaneously using powers of 2 until their ancestors converge.
This method works in O(log N) time for each query after an O(N log N) preprocessing step


***** Binary Search Tree (BST) *************

The way we received values that part is critical in BST (see how we take value in root->left or root->right that joins new node with parent)

Insert a node in BST ?

Just traverse the tree with comparing values till you reach null at that point we have result 

TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == NULL) {
            return new TreeNode(val);
        }

        if(val > root->val) {
            root->right = insertIntoBST(root->right, val);
        } else {
            root->left = insertIntoBST(root->left, val); 
        }

        return root;
}


Delete a node in BST ?

First we need to find the root to be deleted. That root can have 3 types , 0 child, 1 child, 2 child (all these need to be handled)

Incase of two child we find largest in left tree or smallest in right tree and replace that value with node

TreeNode* find(TreeNode* root) {
        TreeNode* pre = root->left;
        while(pre && pre->right) pre= pre->right;
        return pre;
    }
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root == NULL) return NULL;

        if(root->val > key) {
            root->left = deleteNode(root->left, key);
        } else if(root->val < key) {
            root->right = deleteNode(root->right, key);
        } else {
           if(!root->left && !root->right) {
            // Leaf node
            return NULL;
           } else if(!root->left) {
             return root->right;
           } else if(!root->right) {
            return root->left;
           } else {
            // two children
            TreeNode* pre = find(root);
            root->val = pre->val;
            root->left = deleteNode(root->left, pre->val);
            return root;
           }
        }

        return root;
}

Find inorder successor of node in BST ?

if node has no right than we need to find its parent and check otherwise its straightforwrad (see how we use pass by ref here)
 void find(Node *root, Node* x, Node*& par) {
        if(root == NULL) return;
        if(root->data > x->data) {
           par = root;
           find(root->left, x , par);
        } else if(root->data < x->data) {
          find(root->right, x, par);
        } else {
            return;
        }
    }
    Node * inOrderSuccessor(Node *root, Node *x)
    {
        //Your code here
        
        if(root == NULL) return root;
        
        if(x->right == NULL) {
            Node *par = NULL;
            find(root, x, par);
            return par;
        } else {
            Node* temp = x->right;
            while(temp->left) temp= temp->left;
            return temp;
        }
        
        return NULL;
    }

Kth smallest number in bst 

We have to use the inituition that inorder travel gives us numbers in sorted order , so if we keep count and reach kth number we should reach correct number 

int inOrderTraversal(TreeNode* node, int k, int& count) {
        // Base case: If the node is NULL, return -1 (or any invalid value)
        if (node == nullptr) {
            return -1; // Indicates the k-th smallest wasn't found
        }

        // Traverse the left subtree
        int leftResult = inOrderTraversal(node->left, k, count);
        if (leftResult != -1) {
            return leftResult; // If found in left subtree, return it
        }

        // Visit this node
        count++;
        if (count == k) {
            return node->val; // Found the k-th smallest element
        }

        // Traverse the right subtree
        return inOrderTraversal(node->right, k, count);
}

Valid BST (same is used in Preorder to BST)

bool isValidBST(TreeNode* root, long minVal = LONG_MIN, long maxVal = LONG_MAX) {
    if (root == NULL) return true;  // An empty tree is a valid BST

    // Check if the current node's value is within the allowed range
    if (root->val <= minVal || root->val >= maxVal) {
        return false;  // Violates the BST property
    }

    // Recursively validate left and right subtrees with updated ranges
    return isValidBST(root->left, minVal, root->val) && isValidBST(root->right, root->val, maxVal);
}

There is another way to do this which we can use to solve other problems also (like max size BST in a B-Tree thus listing here)

All nodes must follow the property of being smaller than all their right nodes and being bigger than all their left nodes

The key observation is for all nodes we want to validate something which consistes of a property which can be influenced by all its children so we need Post-order traversal

So the info we will ask from each node is if the tree rooted at it is BST , min in it tree and max in its tree 

struct Node {
       bool isBst;
       int min;
       int max;
    };
    Node helper(TreeNode* root) {

        if(root == NULL) {
            return {true, INT_MAX, INT_MIN};
        }

        if(root->left == NULL && root->right == NULL) {
            return {true, root->val, root->val};
        } // leaf

        Node left = helper(root->left);
        Node right = helper(root->right);

        bool isNodeBst = left.isBst && right.isBst && root->val < right.min && root->val > left.max;

        int Max = max(root->val, right.max);
        int Min = min(root->val, left.min);

       return {isNodeBst, Min, Max}; }

one improtant question is since we only max of left and right of min why are we asking for both info (answer is to calculate my min and max)


To solve largest bst in B-tree take the same Node add a size property which is largest BST inside me with this condition 
when i am bst its size is l-bstSize + r-bstSize + 1 when i am not it is max(l-bstSize, r-bstSize)

kth largest element in BST 

for kth smallest we can simply do inorder traversal and keep count of all nodes seen as we kth node we get answer 
for kth largest we can do similar just need to rely on traversing right first 

class Solution {
  public:
    int solve(Node* root, int &x, int &runner) {
        if(root == NULL) return -1;
        
        int right = solve(root->right, x, runner);
        if(right != -1) return right;
        
        if(x == runner) return root->data;
        runner++;
        
        return solve(root->left, x, runner);
    }
    int kthLargest(Node *root, int k) {
        int runner = 1;
        
        return solve(root, k, runner);
        
    }
};


Pair of numbers which sum to target in BST 

> do inorder traversal store result in array than its 2-sum
> One other way is to push all left nodes in a stack and all right nodes in a another stack (than again we do 2 sum type)
while popping from left add all its right child , while popping from right add all its left child


BST iterator (iterator for inorder traversal of BST)

> Push all leftmost child in stack
> Now whenever top is called (we pop stack top) and push all left child of right child of current node

class BSTIterator {
private:
    stack<TreeNode*> st;

    void pushLeft(TreeNode* node) {
        while (node) {
            st.push(node);
            node = node->left;  // Move to the leftmost child
        }
    }

public:
    // Constructor: Initialize the iterator with the root of the BST
    BSTIterator(TreeNode* root) {
        pushLeft(root);  // Start the traversal from the root
    }

    // Returns true if there is a next number
    bool hasNext() {
        return !st.empty();  // Check if there are more elements
    }

    // Returns the next number in the BST
    int next() {
        TreeNode* node = st.top();
        st.pop();  // Remove the node from the stack
        pushLeft(node->right);  // Push the leftmost nodes of the right subtree
        return node->val;  // Return the current node's value
    }
};


Sorted array to BST / Inorder to BST

TreeNode* buildBST(vector<int>& nums, int left, int right) {
        if (left > right) {
            return nullptr; // Base case
        }
        
        int mid = left + (right - left) / 2; // Find the middle index
        TreeNode* root = new TreeNode(nums[mid]); // Create the root node
        
        // Recursively build the left and right subtrees
        root->left = buildBST(nums, left, mid - 1);
        root->right = buildBST(nums, mid + 1, right);
        
        return root; // Return the root of the subtree
}

Preorder to BST 

TreeNode* buildTree(std::vector<int>& preorder, int& index, int minVal, int maxVal) {
        // Base case: If index is out of bounds or value is not in range
        if (index >= preorder.size() || preorder[index] < minVal || preorder[index] > maxVal) {
            return nullptr;
        }
        
        // Create the root node with the current value
        TreeNode* root = new TreeNode(preorder[index]);
        index++; // Move to the next element
        
        // Recursively build the left and right subtrees
        root->left = buildTree(preorder, index, minVal, root->val); // Restrict max for left subtree
        root->right = buildTree(preorder, index, root->val, maxVal); // Restrict min for right subtree
        
        return root; // Return the root of the subtree
 }



 *** Segment Trees ****


 Used for range based queries where we need to find results for a range and update range etc (ex range sum/ max/ min etc)

 How it works :: ex 5 6 2 3 and we are building a segment tree for sum nodes , root will contain (0, 3) and its sum (16) now we will calculate m = (l + r)/2
 and make a left child for (l, m) (0, 1) (11) and (m+1,r) (2, 3) (5) and so on 

 Leafes will be all individual elements 

 Height of tree is logN and its a balanced binary tree (meaning max diff between height of 2 child is <= 1)
 number of nodes in a segment tree is always 2*N (N for all leaf, than N/2 --> N/4 and so on )

 The code representation of this can be done in form of array where 2i+1 and 2i+2 are child for every i node

Build tree is easy we rely on recursion to build left and right and i just create root itself 

vector<int> segTree(4n, -1); // take 4n always to avoid overflow etc


Void buildTree(int index, int left, int right) {

if(left == right) {
segTree[index] = nums[left];
Return; }

Int m = (left + right)/2;

buildTree(2*index+1, left, m);
buildTree(2*index+2, m+1, right);

segTree[index] = segTree[2*index+1] + segTree[2*index+2];

return;

}

Second thing is if update comes to us --> find the correct leaf to update (since all nodes are at leaf and than we propagate similar to build)

void update(int index_update, int val, int index, int left, int right) {
    if (left == right) {
        segTree[index] = val;
        return;
    }

    Int mid = (left + right)/2;

    if (index_update <= mid) {
        update(index_update, val, 2 * index + 1, left, mid);
    } else {
        update(index_update, val, 2 * index + 2, mid + 1, right);
    }

    segTree[index] = segTree[2 * index + 1] + segTree[2 * index + 2];
}

Query the tree 


In this we will be given range ex [0,2] and we need to find sum for range , every node of our tree represents a range [start, end] 
the trick is again that we can have 3 cases of interaction between this


The node i represent is completely out of bound → return 0

The node i represent is completely inside query → return myval

Else i query on my left and rightChild

int sum(int start, int end, int index, int left, int right) {
    if (left > end || right < start) {
        return 0; // Out of bound case
    }

    if (left >= start && right <= end) {
        return segTree[index]; // Current segment is fully within range
    }

    int mid = left + (right - left) / 2;

    return sum(start, end, 2 * index + 1, left, mid) + 
           sum(start, end, 2 * index + 2, mid + 1, right);
}


Range update (instead of changing a index we change a range of indexes ) (If we follow point update for all it becomes logN for all numbers so NlogN)
watch :: https://www.youtube.com/watch?v=FB_LjtTQwlw&list=PLpIkg8OmuX-K1qUIQToCllUO0UIKXt8dB&index=7

void update(int start, int end, int val, int index, int left, int right) {

    if(lazy[index] != 0) {
        seg[index] = (right - left + 1) * lazy[i];
        if (left != right) {
         seg[2*index + 1] = lazy[i];
         seg[2*index + 2] = lazy[i]
        }
        lazy[i] = 0;
    }

    if(start > right || end < left)  return;

    if(left >= start && right <= end) {
        seg[index] = (right - left + 1) * lazy[i];
         lazy[2*index + 1] = val;
         lazy[2*index + 2] = val;
    }

    call recursion
}

315. Count of numbers smaller after self 

This question is a smart application of segment tree 

> compression is done to save space not entirely necessary for issue (basically if array is 0 --> 220 --> 400) we convert to (0 --> 1 --> 2) and tree is 
smaller but result is same

We basically want to count number of elements in range [0, number - 1] , so consider it same problem as segmentTree sum basically with sum as 1 for each node

class Solution {
private:
    vector<int> segTree; // Segment Tree Array

    // Function to update the segment tree at a specific index
    void updateTree(int idx, int value, int index, int left, int right) {
        if (left == right) {
            segTree[index] += value; // Update the count at the leaf node
            return;
        }

        int mid = left + (right - left) / 2;
        if (idx <= mid) {
            updateTree(idx, value, 2 * index + 1, left, mid);
        } else {
            updateTree(idx, value, 2 * index + 2, mid + 1, right);
        }

        // Update the current node's value after updating children
        segTree[index] = segTree[2 * index + 1] + segTree[2 * index + 2];
    }

    // Function to query the segment tree for a range sum
    int queryTree(int start, int end, int index, int left, int right) {
        if (left > end || right < start) {
            return 0; // Out of range
        }

        if (left >= start && right <= end) {
            return segTree[index]; // Completely within range
        }

        int mid = left + (right - left) / 2;
        int leftSum = queryTree(start, end, 2 * index + 1, left, mid);
        int rightSum = queryTree(start, end, 2 * index + 2, mid + 1, right);

        return leftSum + rightSum;
    }

    // Function for coordinate compression
    vector<int> compressCoordinates(const vector<int>& nums) {
        vector<int> sortedNums = nums;
        sort(sortedNums.begin(), sortedNums.end());
        vector<int> compressed(nums.size());

        for (size_t i = 0; i < nums.size(); ++i) {
            compressed[i] = lower_bound(sortedNums.begin(), sortedNums.end(), nums[i]) - sortedNums.begin();
        }
        maxVal = sortedNums.size(); // Set maxVal for the segment tree range
        return compressed;
    }

public:
    vector<int> countSmaller(vector<int>& nums) {
        if (nums.empty()) return {};

        // Step 1: Coordinate Compression
        vector<int> compressed = compressCoordinates(nums);
        int maxVal = nums.size();

        // Step 2: Initialize Segment Tree
        segTree.resize(4 * maxVal, 0); // All nodes are initialized to 0

        // Step 3: Process the array in reverse order
        vector<int> result(nums.size());
        for (int i = nums.size() - 1; i >= 0; --i) {
            // Query for the count of numbers smaller than current number
            result[i] = queryTree(0, compressed[i] - 1, 0, 0, maxVal - 1);

            // Update the segment tree to include the current number
            updateTree(compressed[i], 1, 0, 0, maxVal - 1);
        }

        return result;
    }
};